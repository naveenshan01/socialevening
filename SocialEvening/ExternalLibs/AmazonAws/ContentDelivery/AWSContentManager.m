//
//  AWSContentManager.m
//
//
// Copyright 2015 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to 
// copy, distribute and modify it.
//

#import "AWSContentManager.h"

#import <AWSS3/AWSS3.h>
#import "AWSCorePrivateHeader.h"
#import "AWSConfiguration.h"
#import "AWSTask+CheckExceptions.h"

#import <CommonCrypto/CommonCryptor.h>
#import <CommonCrypto/CommonDigest.h>

NSString *const AWSContentManagerErrorDomain = @"com.amazonaws.AWSContentManager.ErrorDomain";

NSString *const AWSContentManagerContentCacheName = @"com.amazonaws.AWSContentManager.ContentCacheName";
NSString *const AWSContentManagerPinnedCacheName = @"com.amazonaws.AWSContentManager.PinnedCacheName";

NSUInteger const AWSContentManagerDefaultByteLimit = 20 * 1024  * 1024; // 20 MB

NSString *const AWSContentManagerUserDefaultsByteLimitKey = @"com.amazonaws.AWSContentManager.ByteLimit";

NSUInteger const AWSContentManagerMaxKeys = 100;

@protocol AWSContentProvider <NSObject>

@required

- (void)GETURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler;

- (void)PUTURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler;

- (void)DELETEURLForKey:(NSString *)key
      completionHandler:(void (^)(NSURL *, NSError *))completionHandler;

@end

@interface AWSContentManager() <NSURLSessionDelegate>

@property (nonatomic, strong) NSMutableDictionary *contents;
@property (nonatomic, strong) AWSTMCache *contentCache;
@property (nonatomic, strong) AWSTMCache *pinnedCache;
@property (nonatomic, strong) id<AWSContentProvider> contentProvider;
@property (nonatomic, strong) NSURLSession *URLSession;
@property (nonatomic, strong) NSMutableDictionary *runningTasks;

@property (nonatomic, strong) NSMutableArray *uploadingContents;

@property (nonatomic, strong) NSString *bucket;

@end

@interface AWSLocalContent : AWSContent

- (void)uploadWithPinOnCompletion:(BOOL)pinOnCompletion
                    progressBlock:(void(^)(AWSLocalContent *content, NSProgress *progress))progressBlock
                completionHandler:(void(^)(AWSLocalContent *content, NSError *error))completionHandler;

@end

@interface AWSContent()

@property (nonatomic, strong) AWSContentManager *manager;

@property (nonatomic, assign, getter=isDirectory) BOOL directory;
@property (nonatomic, assign) AWSContentStatusType status;
@property (nonatomic, assign) NSProgress *progress;
@property (nonatomic, strong) NSString *key;
@property (nonatomic, strong) NSDate *knownRemoteLastModifiedDate;
@property (nonatomic, assign) NSUInteger knownRemoteByteCount;

@property (nonatomic, strong) NSData *temporaryData;
@property (nonatomic, copy) void(^downloadProgressBlock)(AWSContent *content, NSProgress *progress);
@property (nonatomic, copy) void(^downloadCompletionHandler)(AWSContent *content, NSData *data, NSError *error);
@property (nonatomic, assign) BOOL pinOnCompletion;

@property (nonatomic, strong) NSData *uploadData;
@property (nonatomic, copy) void(^uploadProgressBlock)(AWSLocalContent *content, NSProgress *progress);
@property (nonatomic, copy) void(^uploadCompletionHandler)(AWSLocalContent *content, NSError *error);

- (instancetype)initWithManager:(AWSContentManager *)manager;

@end

@interface AWSS3ContentProvider : NSObject <AWSContentProvider>

@property (readonly) NSString *bucket;

- (instancetype)initWithBucket:(NSString *)bucket;

@end

@interface AWSCloudFrontContentProvider : NSObject <AWSContentProvider>

@property (readonly) NSString *domain;

- (instancetype)initWithDomain:(NSString *)domain;

@end

@interface NSURL (AWS)

- (id)aws_getResourceValue:(NSString *)key;

@end

@interface NSData (AWS)

- (NSString *)aws_md5String;

@end

@interface AWSTMDiskCache (AWS)

- (NSURL *)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key;
- (void)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key block:(AWSTMDiskCacheObjectBlock)block;

@end

#pragma mark - AWSContentManager

typedef NS_ENUM(NSInteger, AWSContentManagerType){
    AWSContentManagerTypeS3,
    AWSContentManagerTypeCloudFront,
};

@implementation AWSContentManager

#pragma mark - Initializers


- (instancetype)initWithType:(AWSContentManagerType)type
                      bucket:(NSString *)bucket
                      domain:(NSString *)domain
                  identifier:(NSString *)identifier {
    if (self = [super init]) {
        _contents = [NSMutableDictionary new];
        _runningTasks = [NSMutableDictionary new];
        _uploadingContents = [NSMutableArray new];

        // Gets Application Support directory.
        NSFileManager *fileManager = [NSFileManager defaultManager];
        NSArray *URLs = [fileManager URLsForDirectory:NSApplicationSupportDirectory
                                            inDomains:NSUserDomainMask];
        NSURL *URL = nil;
        if ([URLs count] > 0) {
            URL = URLs[0];
            _contentCache = [[AWSTMCache alloc] initWithName:[NSString stringWithFormat:@"%@-%@", AWSContentManagerContentCacheName, identifier]
                                                    rootPath:URL.path];
            _pinnedCache = [[AWSTMCache alloc] initWithName:[NSString stringWithFormat:@"%@-%@", AWSContentManagerPinnedCacheName, identifier]
                                                   rootPath:URL.path];

            _contentCache.diskCache.byteLimit = self.maxCacheSize;

            if (type == AWSContentManagerTypeS3) {
                _contentProvider = [[AWSS3ContentProvider alloc] initWithBucket:bucket];
            } else if (type == AWSContentManagerTypeCloudFront) {
                _contentProvider = [[AWSCloudFrontContentProvider alloc] initWithDomain:domain];
            } else {
                assert(false);
            }

            _bucket = bucket;

            NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
            _URLSession = [NSURLSession sessionWithConfiguration:configuration
                                                        delegate:self
                                                   delegateQueue:[NSOperationQueue mainQueue]];
        } else {
            AWSLogError(@"Failed to retrieve the Application Support directory.");
        }
    }
    return self;
}

#pragma mark - Properties

- (NSUInteger)maxCacheSize {

    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    NSNumber *byteLimit = [userDefaults objectForKey:AWSContentManagerUserDefaultsByteLimitKey];
    if (!byteLimit) {
        return AWSContentManagerDefaultByteLimit;
    }
    return [byteLimit unsignedIntegerValue];
}

- (void)setMaxCacheSize:(NSUInteger)byteLimit {

    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    [userDefaults setObject:@(byteLimit)
                     forKey:AWSContentManagerUserDefaultsByteLimitKey];
    self.contentCache.diskCache.byteLimit = byteLimit;
}

- (NSUInteger)cachedUsedSize {
    return self.contentCache.diskByteCount;
}

- (NSUInteger)pinnedSize {
    return self.pinnedCache.diskByteCount;
}

#pragma mark - User action methods

- (void)getContentWithKey:(NSString *)key
        completionHandler:(void (^)(AWSS3GetObjectOutput *result, NSError *error))completionHandler {
    AWSS3 *s3 = [AWSS3 defaultS3];
    
    AWSS3GetObjectRequest *getObjectRequest = [AWSS3GetObjectRequest new];
    getObjectRequest.bucket = self.bucket;
    getObjectRequest.key = key;

    [[s3 getObject:getObjectRequest] continueWithBlock:^id(AWSTask *task) {
        if (task.error) {
            completionHandler(nil, task.error);
        }
        if (task.exception) {
            @throw task.exception;
        }
        if (task.result) {
            AWSS3GetObjectOutput *output = task.result;
            completionHandler(output, nil);
        }
        return nil;
    }];
}

- (void)listAvailableContentsWithPrefix:(NSString *)prefix
                                 marker:(NSString *)marker
                      completionHandler:(void (^)(NSArray *contents, NSString *nextMarker, NSError *error))completionHandler {
    AWSS3 *s3 = [AWSS3 defaultS3];

    AWSS3ListObjectsRequest *listObjectsRequest = [AWSS3ListObjectsRequest new];
    listObjectsRequest.bucket = self.bucket;
    listObjectsRequest.maxKeys = @(AWSContentManagerMaxKeys);
    listObjectsRequest.marker = marker;
    listObjectsRequest.delimiter = @"/";
    if (prefix) {
        listObjectsRequest.prefix = prefix;
    }

    __weak AWSContentManager *weakSelf = self;
    [[s3 listObjects:listObjectsRequest] continueWithBlock:^id(AWSTask *task) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if (task.error) {
                completionHandler(nil, nil, task.error);
            }
            if (task.exception) {
                @throw task.exception;
            }
            if (task.result) {
                AWSS3ListObjectsOutput *listObjectsOutput = task.result;

                NSMutableDictionary *activeKeys = [NSMutableDictionary new];

                for (AWSS3Object *object in listObjectsOutput.contents) {
                    AWSContent *content = [weakSelf contentForKey:object.key];

                    content.knownRemoteLastModifiedDate = object.lastModified;
                    content.knownRemoteByteCount = [object.size integerValue];

                    [activeKeys setObject:object.key forKey:object.key];
                }

                if (!marker) {
                    for (NSString *key in [weakSelf.contents allKeys]) {
                        if (![activeKeys objectForKey:key]) {
                            [weakSelf.contents removeObjectForKey:key];
                        }
                    }
                }

                for (AWSS3CommonPrefix *commonPrefix in listObjectsOutput.commonPrefixes) {
                    AWSContent *content = [weakSelf contentForKey:commonPrefix.prefix];
                    content.directory = YES;

                    [activeKeys setObject:commonPrefix.prefix forKey:commonPrefix.prefix];
                }

                [weakSelf.contentCache.diskCache enumerateObjectsWithBlock:^(AWSTMDiskCache *cache,
                                                                             NSString *key,
                                                                             id<NSCoding> object,
                                                                             NSURL *fileURL) {
                    [weakSelf contentForKey:key];
                }];
                [weakSelf.pinnedCache.diskCache enumerateObjectsWithBlock:^(AWSTMDiskCache *cache,
                                                                            NSString *key,
                                                                            id<NSCoding> object,
                                                                            NSURL *fileURL) {
                    [weakSelf contentForKey:key];
                }];

                NSArray *contents = [weakSelf filteredContentsWithPrefix:prefix];
                NSString *nextMarker = listObjectsOutput.nextMarker;
                completionHandler(contents, nextMarker, nil);
            }
        });
        return nil;
    }];
}

- (void)listRecentContentsWithPrefix:(NSString *)prefix
                   completionHandler:(void (^)(id result, NSError *error))completionHandler {
    __block NSMutableArray *recentContents = [NSMutableArray new];
    [[self listRecentContents:recentContents
                   nextMarker:nil
                      prefix:prefix
                     counter:10] continueWithExceptionCheckingBlock:^(id result, NSError *error) {
        if (error) {
            completionHandler(nil, error);
            return;
        }

        NSArray *sortedContents = [recentContents sortedArrayUsingComparator:^NSComparisonResult(AWSS3Object * _Nonnull obj1, AWSS3Object * _Nonnull obj2) {
            return [obj2.lastModified compare:obj1.lastModified];
        }];
        recentContents = nil;

        NSMutableArray *resultArray = [NSMutableArray new];

        NSUInteger availableCacheByteCount = self.maxCacheSize - self.cachedUsedSize;
        for (AWSS3Object *object in sortedContents) {
            NSUInteger size = [object.size unsignedIntegerValue];
            if (size > 0
                && ![self.contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:object.key]
                && ![self.pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:object.key]
                && size + 4 * 1024 < availableCacheByteCount) {
                availableCacheByteCount -= size + 4 * 1024;

                AWSContent *content = [self contentForKey:object.key];
                [resultArray addObject:content];
            }
        }
        completionHandler(resultArray, nil);
    }];
}

- (AWSTask *)listRecentContents:(NSMutableArray *)recentContents
                     nextMarker:(NSString *)nextMarker
                         prefix:(NSString *)prefix
                        counter:(int32_t)counter {
    AWSS3 *s3 = [AWSS3 defaultS3];
    AWSS3ListObjectsRequest *listObjectsRequest = [AWSS3ListObjectsRequest new];
    listObjectsRequest.bucket = self.bucket;
    listObjectsRequest.marker = nextMarker;
    listObjectsRequest.prefix = prefix;

    return [[s3 listObjects:listObjectsRequest] continueWithSuccessBlock:^id(AWSTask *task) {
        if ([task.result isKindOfClass:[AWSS3ListObjectsOutput class]]) {
            AWSS3ListObjectsOutput *listObjectsOutput = task.result;
            [recentContents addObjectsFromArray:listObjectsOutput.contents];

            if (counter > 0 && [listObjectsOutput.isTruncated boolValue]) {
                NSString *nextMarker = listObjectsOutput.nextMarker;
                if (!nextMarker) {
                    AWSS3Object *lastObject = [listObjectsOutput.contents lastObject];
                    nextMarker = lastObject.key;
                }
                return [self listRecentContents:recentContents
                                     nextMarker:nextMarker
                                         prefix:prefix
                                        counter:counter - 1];
            }
        }
        return nil;
    }];
}

- (NSArray *)filteredContentsWithPrefix:(NSString *)prefix {
    NSString *currentDirectory = nil;
    NSArray *sortedContents = [[self.contents allValues] sortedArrayUsingComparator:^NSComparisonResult(AWSContent *obj1, AWSContent *obj2) {
        return [obj1.key compare:obj2.key];
    }];
    NSMutableArray *contents = [NSMutableArray new];
    for (AWSContent *content in sortedContents) {
        if ((!prefix || [content.key hasPrefix:prefix]) && ![content.key isEqualToString:prefix]) {
            if (currentDirectory && [content.key hasPrefix:currentDirectory]) {
                continue;
            }

            [contents addObject:content];

            if (content.isDirectory) {
                currentDirectory = content.key;
            }
        }
    }

    return contents;
}

- (AWSContent *)contentForKey:(NSString *)key {
    AWSContent *content = [self.contents objectForKey:key];
    if (!content) {
        content = [[AWSContent alloc] initWithManager:self];
        content.key = key;
        [self.contents setValue:content
                         forKey:content.key];
    }
    return content;
}

- (void)clearCache {
    [self.contents removeAllObjects];
    [self.contentCache removeAllObjects];
    [self.pinnedCache removeAllObjects];
}

- (AWSContent *)contentWithKey:(NSString *)key {
    AWSContent *content = [self contentForKey:key];
    return content;
}

#pragma mark - NSURLSessionTaskDelegate

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error {
    if ([task isKindOfClass:[NSURLSessionDownloadTask class]]) {
        AWSContent *content = self.runningTasks[@(task.taskIdentifier)];
        NSData *data = nil;

        if (!error) {
            NSHTTPURLResponse *HTTPResponse = (NSHTTPURLResponse *)task.response;
            if (HTTPResponse.statusCode / 100 == 4) {
                error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                                           code:AWSContentManagerErrorTypeClientException
                                                       userInfo:nil];
                AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                data = content.temporaryData;
            } else if (HTTPResponse.statusCode / 100 == 5) {
                error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                                           code:AWSContentManagerErrorTypeServiceException
                                                       userInfo:nil];
                AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                data = content.temporaryData;
            } else  if (HTTPResponse.statusCode == 304) { // Not Modified
                data = content.cachedData;
                if (content.pinOnCompletion) {
                    if([self.contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:content.key]) {
                        [content pin];
                    }
                }
            } else {
                data = content.temporaryData;
                if (content.pinOnCompletion) {
                    [self.pinnedCache.diskCache setObject:data
                                                   forKey:content.key];
                } else {
                    [self.contentCache.diskCache setObject:data
                                                    forKey:content.key];
                }
            }
        }

        content.downloadCompletionHandler(content, data, error);

        content.temporaryData = nil;
        content.downloadCompletionHandler = nil;
        content.downloadProgressBlock = nil;

        content.status = AWSContentStatusTypeCompleted;
    } else if ([task isKindOfClass:[NSURLSessionDataTask class]]) {
        AWSLocalContent *content = self.runningTasks[@(task.taskIdentifier)];

        [self.uploadingContents removeObject:content];

        if (content.pinOnCompletion) {
            [self.pinnedCache.diskCache setObject:content.uploadData
                                           forKey:content.key];
        }

        content.uploadCompletionHandler(content, error);

        content.uploadData = nil;
        content.uploadCompletionHandler = nil;
        content.uploadProgressBlock = nil;
    }

    [self.runningTasks removeObjectForKey:@(task.taskIdentifier)];
}

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
    id content = self.runningTasks[@(task.taskIdentifier)];

    if ([content isKindOfClass:[AWSLocalContent class]]) {
        AWSLocalContent *localContent = content;
        localContent.progress.completedUnitCount = totalBytesSent;
        localContent.progress.totalUnitCount = totalBytesExpectedToSend;
        localContent.uploadProgressBlock(localContent, localContent.progress);
    }
}

#pragma mark - NSURLSessionDownloadDelegate

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location {

    AWSContent *content = self.runningTasks[@(downloadTask.taskIdentifier)];
    content.temporaryData = [NSData dataWithContentsOfURL:location];
}

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {

    AWSContent *content = self.runningTasks[@(downloadTask.taskIdentifier)];
    content.progress.completedUnitCount = totalBytesWritten;
    content.progress.totalUnitCount = totalBytesExpectedToWrite;
    content.downloadProgressBlock(content, content.progress);
}

@end

#pragma mark - AWSContent

@implementation AWSContent

- (instancetype)init {
    assert(false);
}

- (instancetype)initWithManager:(AWSContentManager *)manager {
    if (self = [super init]) {
        _manager = manager;
        _directory = NO;
        _status = AWSContentStatusTypeNotStarted;
    }
    return self;
}

#pragma mark - Properties

- (BOOL)isCached {
    AWSTMCache *contentCache = self.manager.contentCache;
    AWSTMCache *pinnedCache = self.manager.pinnedCache;
    return [contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key]
    || [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
}

- (BOOL)isPinned {
    AWSTMCache *pinnedCache = self.manager.pinnedCache;
    return [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key] != nil;
}

- (NSDate *)downloadedDate {
    AWSTMCache *contentCache = self.manager.contentCache;
    NSURL *fileURL = [contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
    NSDate *downloadDate = [fileURL aws_getResourceValue:NSURLCreationDateKey];

    if (!downloadDate) {
        AWSTMCache *pinnedCache = self.manager.pinnedCache;
        fileURL = [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
        downloadDate = [fileURL aws_getResourceValue:NSURLCreationDateKey];
    }

    return downloadDate;
}

- (NSUInteger)fileSize {
    AWSTMCache *contentCache = self.manager.contentCache;
    NSURL *fileURL = [contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
    NSNumber *totalFileAllocatedSize = [fileURL aws_getResourceValue:NSURLTotalFileAllocatedSizeKey];

    if (!totalFileAllocatedSize) {
        AWSTMCache *pinnedCache = self.manager.pinnedCache;
        fileURL = [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
        totalFileAllocatedSize = [fileURL aws_getResourceValue:NSURLTotalFileAllocatedSizeKey];
    }

    return [totalFileAllocatedSize unsignedIntegerValue];
}

- (NSProgress *)progress {
    if (!_progress) {
        _progress = [NSProgress new];
    }
    return _progress;
}

#pragma mark - User action methods

- (void)downloadWithDownloadType:(AWSContentDownloadType)loadingType
                 pinOnCompletion:(BOOL)pinOnCompletion
                   progressBlock:(void(^)(AWSContent *content, NSProgress *progress))progressBlock
               completionHandler:(void(^)(AWSContent *content, NSData *data, NSError *error))completionHandler {
    if (self.isDirectory) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeDirectoryCannotBeDownloaded
                                         userInfo:nil];
        completionHandler(self, nil, error);
        return;
    }
    if (self.status == AWSContentStatusTypeRunning) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeTransferAlreadyInProgress
                                         userInfo:nil];
        completionHandler(self, nil, error);
        return;
    }

    if (loadingType == AWSContentDownloadTypeIfNotCached) {
        NSData *cachedData = self.cachedData;
        if (cachedData) {
            completionHandler(self, cachedData, nil);
            return;
        }
    }

    self.status = AWSContentStatusTypeRunning;
    self.downloadCompletionHandler = completionHandler;
    self.downloadProgressBlock = progressBlock;

    AWSContentManager *contentManager = self.manager;

    __weak AWSContent *weakSelf = self;
    [contentManager.contentProvider GETURLForKey:self.key
                               completionHandler:^(NSURL *URL, NSError *error) {
                                   if (!URL && !error) {
                                       @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                                                      reason:@"The content provider returned nil for the URL and error. This should not happen."
                                                                    userInfo:nil];
                                   }
                                   if (error) {
                                       completionHandler(weakSelf, nil, error);
                                   }
                                   if (URL) {
                                       NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
                                       request.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;
                                       request.HTTPMethod = @"GET";
                                       [request setValue:[NSString aws_baseUserAgent] forHTTPHeaderField:@"User-Agent"];

                                       if (loadingType == AWSContentDownloadTypeIfNewerExists) {
                                           NSData *cachedData = weakSelf.cachedData;
                                           if (cachedData) {
                                               [request setValue:[cachedData aws_md5String] forHTTPHeaderField:@"If-None-Match"];
                                           }
                                       }

                                       NSURLSessionDownloadTask *downloadTask = [contentManager.URLSession downloadTaskWithRequest:request];

                                       contentManager.runningTasks[@(downloadTask.taskIdentifier)] = weakSelf;
                                       weakSelf.pinOnCompletion = pinOnCompletion;

                                       [downloadTask resume];
                                   }
                               }];
}

- (NSData *)cachedData {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;

    id object = [contentCache objectForKey:self.key];
    if (!object) {
        AWSTMCache *pinnedCache = contentManager.pinnedCache;
        object = [pinnedCache objectForKey:self.key];
    }

    return object;
}

- (void)pin {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    AWSTMCache *pinnedCache = contentManager.pinnedCache;

    id object = [contentCache objectForKey:self.key];
    [pinnedCache.diskCache setObject:object
                              forKey:self.key];
    [contentCache removeObjectForKey:self.key];
}

- (void)unPin {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    AWSTMCache *pinnedCache = contentManager.pinnedCache;

    id object = [pinnedCache objectForKey:self.key];
    [contentCache.diskCache setObject:object
                               forKey:self.key];
    [pinnedCache removeObjectForKey:self.key];
}

- (void)removeLocal {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    AWSTMCache *pinnedCache = contentManager.pinnedCache;

    [contentCache removeObjectForKey:self.key];
    [pinnedCache removeObjectForKey:self.key];
}

- (void)removeRemoteContentWithCompletionHandler:(void(^)(AWSContent *content, NSError *error))completionHandler {
    if (self.status == AWSContentStatusTypeRunning) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeTransferAlreadyInProgress
                                         userInfo:nil];
        completionHandler(self, error);
        return;
    }

    self.status = AWSContentStatusTypeRunning;

    AWSContentManager *contentManager = self.manager;

    __weak AWSContent *weakSelf = self;
    [contentManager.contentProvider DELETEURLForKey:self.key
                                  completionHandler:^(NSURL *URL, NSError *error) {
                                      if (!URL && !error) {
                                          @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                                                         reason:@"The content provider returned nil for the URL and error. This should not happen."
                                                                       userInfo:nil];
                                      }
                                      if (error) {
                                          completionHandler(weakSelf, error);
                                      }
                                      if (URL) {
                                          NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
                                          request.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;
                                          request.HTTPMethod = @"DELETE";
                                          [request setValue:[NSString aws_baseUserAgent] forHTTPHeaderField:@"User-Agent"];

                                          NSURLSessionDataTask *downloadTask = [contentManager.URLSession dataTaskWithRequest:request
                                                                                                            completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                                                                                dispatch_async(dispatch_get_main_queue(), ^{
                                                                                                                    NSHTTPURLResponse *HTTPResponse = (NSHTTPURLResponse *)response;
                                                                                                                    if (HTTPResponse.statusCode / 100 == 4) {
                                                                                                                        AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                                                                                                                        NSError *clientError = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                                                                                                                                                   code:AWSContentManagerErrorTypeClientException
                                                                                                                                                               userInfo:nil];
                                                                                                                        completionHandler(weakSelf, clientError);
                                                                                                                    } else if (HTTPResponse.statusCode / 100 == 5) {
                                                                                                                        AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                                                                                                                        NSError *clientError = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                                                                                                                                                   code:AWSContentManagerErrorTypeServiceException
                                                                                                                                                               userInfo:nil];
                                                                                                                        completionHandler(weakSelf, clientError);
                                                                                                                    } else {
                                                                                                                        completionHandler(weakSelf, error);
                                                                                                                    }
                                                                                                                });
                                                                                                            }];
                                          [downloadTask resume];
                                      }
                                  }];
}

@end

@implementation AWSLocalContent

- (instancetype)initWithManager:(AWSContentManager *)manager
                           data:(NSData *)data
                            key:(NSString *)key {
    if (self = [super initWithManager:manager]) {
        self.key = key;
        self.uploadData = data;
    }
    return self;
}

- (void)uploadWithPinOnCompletion:(BOOL)pinOnCompletion
                    progressBlock:(void(^)(AWSLocalContent *content, NSProgress *progress))progressBlock
                completionHandler:(void(^)(AWSLocalContent *content, NSError *error))completionHandler {
    if (self.isDirectory) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeDirectoryCannotBeDownloaded
                                         userInfo:nil];
        completionHandler(self, error);
        return;
    }
    if (self.status == AWSContentStatusTypeRunning) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeTransferAlreadyInProgress
                                         userInfo:nil];
        completionHandler(self, error);
        return;
    }

    self.status = AWSContentStatusTypeRunning;
    self.uploadCompletionHandler = completionHandler;
    self.uploadProgressBlock = progressBlock;

    AWSContentManager *contentManager = self.manager;

    __weak AWSLocalContent *weakSelf = self;
    [contentManager.contentProvider PUTURLForKey:self.key
                               completionHandler:^(NSURL *URL, NSError *error) {
                                   if (!URL && !error) {
                                       @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                                                      reason:@"The content provider returned nil for the URL and error. This should not happen."
                                                                    userInfo:nil];
                                   }
                                   if (error) {
                                       completionHandler(weakSelf, error);
                                   }
                                   if (URL) {
                                       NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
                                       request.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;
                                       request.HTTPMethod = @"PUT";
                                       request.HTTPBody = self.uploadData;
                                       [request setValue:[NSString aws_baseUserAgent] forHTTPHeaderField:@"User-Agent"];

                                       // In order to send an empty HTTP body (for creating a directory in S3), you need to use NSURLSessionDataTask.
                                       // If you need to switch it to NSURLSessionUploadTask, you need to have a separate case for creating a directory.
                                       NSURLSessionDataTask *uploadTask = [contentManager.URLSession dataTaskWithRequest:request];

                                       contentManager.runningTasks[@(uploadTask.taskIdentifier)] = weakSelf;
                                       weakSelf.pinOnCompletion = pinOnCompletion;

                                       [contentManager.uploadingContents addObject:weakSelf];

                                       [uploadTask resume];
                                   }
                               }];
}

@end

#pragma mark - AWSS3ContentProvider

@implementation AWSS3ContentProvider

- (instancetype)init {
    assert(false);
}

- (instancetype)initWithBucket:(NSString *)bucket {
    if (self = [super init]) {
        _bucket = bucket;
    }

    return self;
}

- (void)GETURLForKey:(NSString *)key
   completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    AWSS3PreSignedURLBuilder *s3PreSignedURLBuilder = [AWSS3PreSignedURLBuilder defaultS3PreSignedURLBuilder];
    AWSS3GetPreSignedURLRequest *getPreSignedURLRequest = [AWSS3GetPreSignedURLRequest new];
    getPreSignedURLRequest.bucket = self.bucket;
    getPreSignedURLRequest.key = key;
    getPreSignedURLRequest.HTTPMethod = AWSHTTPMethodGET;
    getPreSignedURLRequest.expires = [NSDate dateWithTimeIntervalSinceNow:50 * 60]; // 50 minutes
    [[s3PreSignedURLBuilder getPreSignedURL:getPreSignedURLRequest] continueWithBlock:^id(AWSTask *task) {
        if (task.error) {
            NSError *error = task.error;
            completionHandler(nil, error);
        }
        if (task.exception) {
            @throw task.exception;
        }
        if (task.result) {
            NSURL *URL = task.result;
            completionHandler(URL, nil);
        }
        return nil;
    }];
}

- (void)PUTURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler {
    AWSS3PreSignedURLBuilder *s3PreSignedURLBuilder = [AWSS3PreSignedURLBuilder defaultS3PreSignedURLBuilder];
    AWSS3GetPreSignedURLRequest *getPreSignedURLRequest = [AWSS3GetPreSignedURLRequest new];
    getPreSignedURLRequest.bucket = self.bucket;
    getPreSignedURLRequest.key = key;
    getPreSignedURLRequest.HTTPMethod = AWSHTTPMethodPUT;
    getPreSignedURLRequest.expires = [NSDate dateWithTimeIntervalSinceNow:50 * 60]; // 50 minutes
    [[s3PreSignedURLBuilder getPreSignedURL:getPreSignedURLRequest] continueWithExecutor:[AWSExecutor mainThreadExecutor] withBlock:^id(AWSTask *task) {
        if (task.error) {
            NSError *error = task.error;
            completionHandler(nil, error);
        }
        if (task.exception) {
            @throw task.exception;
        }
        if (task.result) {
            NSURL *URL = task.result;
            completionHandler(URL, nil);
        }
        return nil;
    }];
}

- (void)DELETEURLForKey:(NSString *)key
      completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    AWSS3PreSignedURLBuilder *s3PreSignedURLBuilder = [AWSS3PreSignedURLBuilder defaultS3PreSignedURLBuilder];
    AWSS3GetPreSignedURLRequest *getPreSignedURLRequest = [AWSS3GetPreSignedURLRequest new];
    getPreSignedURLRequest.bucket = self.bucket;
    getPreSignedURLRequest.key = key;
    getPreSignedURLRequest.HTTPMethod = AWSHTTPMethodDELETE;
    getPreSignedURLRequest.expires = [NSDate dateWithTimeIntervalSinceNow:50 * 60]; // 50 minutes
    [[s3PreSignedURLBuilder getPreSignedURL:getPreSignedURLRequest] continueWithBlock:^id(AWSTask *task) {
        if (task.error) {
            NSError *error = task.error;
            completionHandler(nil, error);
        }
        if (task.exception) {
            @throw task.exception;
        }
        if (task.result) {
            NSURL *URL = task.result;
            completionHandler(URL, nil);
        }
        return nil;
    }];
}

@end

#pragma mark - AWSCloudFrontContentProvider

@implementation AWSCloudFrontContentProvider

- (instancetype)init {
    assert(false);
}

- (instancetype)initWithDomain:(NSString *)domain {
    if (self = [super init]) {
        _domain = domain;
    }

    return self;
}

- (void)GETURLForKey:(NSString *)key
   completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    NSURL *URL = [NSURL URLWithString:key
                        relativeToURL:[NSURL URLWithString:self.domain]];
    completionHandler(URL, nil);
}

- (void)PUTURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler {
    // Not supported.
}

- (void)DELETEURLForKey:(NSString *)key
      completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    // Not supported.
}

@end

#pragma mark - Utility methods

@implementation NSURL (AWS)

- (id)aws_getResourceValue:(NSString *)key {
    NSError *error = nil;
    id objectToRetrieve = nil;
    BOOL result = [self getResourceValue:&objectToRetrieve
                                  forKey:key
                                   error:&error];
    if (!result) {
        AWSLogError(@"Failed to get a resource value for the file URL: %@", error);
    }

    return objectToRetrieve;
}

@end

@implementation NSData (AWS)

- (NSString *)aws_md5String {
    unsigned char digestArray[CC_MD5_DIGEST_LENGTH];
    CC_MD5([self bytes], (CC_LONG)[self length], digestArray);

    NSMutableString *md5String = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
    for (int i = 0; i < CC_MD5_DIGEST_LENGTH; i++) {
        [md5String appendFormat:@"%02x", digestArray[i]];
    }
    return md5String;
}

@end

@interface AWSTMDiskCache ()

@property (assign, nonatomic) dispatch_queue_t queue;

- (NSURL *)encodedFileURLForKey:(NSString *)key;

@end

@implementation AWSTMDiskCache (AWS)

- (NSURL *)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key
{
    if (!key)
        return nil;

    __block NSURL *fileURLForKey = nil;

    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    [self aws_fileURLWithoutUpdatingLastAccessedDateForKey:key block:^(AWSTMDiskCache *cache, NSString *key, id <NSCoding> object, NSURL *fileURL) {
        fileURLForKey = fileURL;
        dispatch_semaphore_signal(semaphore);
    }];

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

#if !OS_OBJECT_USE_OBJC
    dispatch_release(semaphore);
#endif
    
    return fileURLForKey;
}

- (void)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key block:(AWSTMDiskCacheObjectBlock)block
{
    if (!key || !block)
        return;
    
    __weak AWSTMDiskCache *weakSelf = self;
    
    dispatch_async(self.queue, ^{
        AWSTMDiskCache *strongSelf = weakSelf;
        if (!strongSelf)
            return;
        
        NSURL *fileURL = [strongSelf encodedFileURLForKey:key];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]]) {
            fileURL = nil;
        }
        
        block(strongSelf, key, nil, fileURL);
    });
}

@end
